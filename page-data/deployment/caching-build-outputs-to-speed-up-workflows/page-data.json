{"componentChunkName":"component---src-templates-post-template-tsx","path":"/deployment/caching-build-outputs-to-speed-up-workflows/","result":{"data":{"posts":{"edges":[{"node":{"fields":{"slug":"/deployment/caching-build-outputs-to-speed-up-workflows/"},"html":"<h2>들어가며</h2>\n<p>본 내용은 <a href=\"https://mnxmnz.github.io/frontend/caching-dependencies-to-speed-up-workflows\" target=\"_blank\" rel=\"nofollow\">1편</a> 과 이어지는 최적화 내용이지만, Gatsby 빌드 관련 최적화만 확인하실 분들은 2편만 보셔도 충분합니다. 각 내용은 의존성 캐싱과 빌드 결과물 캐싱이라는 완전히 분리된 내용입니다.</p>\n<p>이 글에서는 main 브랜치에 변경 사항을 push 했을 때 자동으로 실행되는 Github Actions 워크플로우의 속도를 빌드 결과물 캐싱을 통해 개선한 방법을 소개합니다. 먼저, Gatsby 의 빌드 과정에 대해 간단히 정리했습니다.</p>\n<h2>1. Gatsby Build</h2>\n<p>Gatsby 는 정적 사이트 생성기로 웹 사이트를 정적 HTML, CSS, JavaScript 파일로 변환해서 더 빠르게 로딩되는 웹 페이지를 생성합니다. Gatsby 상세 내용은 <a href=\"https://mnxmnz.github.io/gatsby/what-is-gatsby\" target=\"_blank\" rel=\"nofollow\">“Gatsby는 처음이라 :: 개념부터 프로젝트 시작까지”</a> 에서 확인하실 수 있습니다.</p>\n<p>Gatsby는 두 가지 실행 모드를 제공합니다.</p>\n<ul>\n<li><strong>Develop</strong>: <code>gatsby develop</code> 명령어로 실행합니다.</li>\n<li><strong>Build</strong>: <code>gatsby build</code> 명령어로 실행합니다.</li>\n</ul>\n<p>블로그에서는 <code>gatsby build</code> 명령어로 생성된 결과물을 캐싱하므로 이와 관련된 내용만 다루겠습니다.</p>\n<p><code>gatsby build</code> 명령어를 실행하면 사이트를 웹 브라우저에 전달할 수 있는 파일로 컴파일해서 최종 완성본을 생성합니다. 최종 완성본은 여러 최적화 단계를 거친 프로덕션에 배포할 수 있는 정적 파일로 구성됩니다. 사이트의 설정, 데이터, 코드 그리고 정적 HTML 페이지를 포함하고 있습니다. 이러한 정적 파일은 이후 클라이언트 측에서 리액트 애플리케이션으로 재구성(Rehydration)됩니다.</p>\n<details>\n<summary>Hydration</summary>\n<p>클라이언트 측 JavaScript 를 사용해서 서버 렌더링 HTML 에 응용 프로그램의 상태와 상호 작용을 추가하는 과정입니다. Hydration 은 초기 정적 HTML 을 동적으로 변환해서 상태와 이벤트 처리를 가능하게 합니다. 이를 통해 웹 페이지는 로딩 속도를 유지하면서도 동적인 기능을 제공할 수 있습니다.</p>\n<p>Gatsby 는 Hydration 을 사용해서 빌드 과정에서 생성된 정적 HTML 을 React 애플리케이션으로 변환합니다.</p>\n</details>\n<p>전체적인 빌드 과정은 다음과 같습니다.</p>\n<ol>\n<li><strong>Node 객체 생성</strong>: <code>gatsby-config.js</code> 파일과 <code>gatsby-node.js</code> 파일을 사용해서 플러그인과 데이터 소스로부터 Node 객체를 생성합니다. Node 객체는 웹 사이트의 데이터를 나타냅니다.</li>\n<li><strong>스키마 생성</strong>: Node 객체를 분석해서 데이터의 구조와 관계를 이해하는 스키마를 생성합니다. 스키마는 GraphQL 쿼리에서 사용됩니다.</li>\n<li><strong>페이지 생성</strong>: JavaScript 컴포넌트를 사용해서 페이지를 생성합니다. 이 과정에서 페이지의 구조와 레이아웃을 결정합니다.</li>\n<li><strong>GraphQL 쿼리 실행</strong>: 각 페이지에서 필요한 데이터를 가져오기 위해 GraphQL 쿼리를 실행합니다. 필요한 정보를 미리 가져와서 페이지 로딩 속도를 최적화합니다.</li>\n<li><strong>정적 파일 생성</strong>: 모든 페이지와 컴포넌트의 내용을 기반으로 정적 파일을 생성합니다. 생성된 정적 파일은 <code>public</code> 디렉터리에 저장됩니다. <code>public</code> 디렉터리의 파일은 서버 없이 웹 브라우저에서 바로 로딩할 수 있는 형태입니다.</li>\n</ol>\n<p>Gatsby는 파일 시스템에서 변경을 감지하여 필요한 부분만 다시 빌드합니다. 데이터 소스나 페이지 컴포넌트 등에 변경 사항이 없으면 이전에 생성한 캐시를 재사용하여 빠르게 빌드합니다.</p>\n<p><code>.cache</code> 디렉터리는 빌드 과정의 중간 단계에서 사용되는 임시 저장소입니다. 빌드 중에 생성되는 중간 결과나 데이터를 저장합니다. 다음 빌드에서는 이전 작업의 결과물을 활용해서 중복 작업을 피하고 빠르게 빌드할 수 있습니다.</p>\n<p>Gatsby는 몇 가지 경우에 캐시를 무효로(invalidated) 합니다.</p>\n<ol>\n<li><strong><code>package.json</code></strong>: 종속성(dependency)이 업데이트되거나 추가되면 <code>package.json</code> 파일이 변경됩니다. 이러한 변경을 감지하여 새로운 종속성 정보를 반영합니다.</li>\n<li><strong><code>gatsby-config.js</code></strong>: 플러그인이 추가되거나 수정되면 플러그인 정보를 업데이트합니다.</li>\n<li><strong><code>gatsby-node.js</code></strong>: 새로운 Node API를 호출하거나 <code>createPage</code> 호출을 변경하면 새로운 노드 작업을 반영합니다.</li>\n</ol>\n<h2>2. 빌드 결과물 캐싱하기</h2>\n<p>Gatsby 빌드 과정에 대해 살펴봤으니 GitHub Actions에서 빌드 결과물을 캐싱하는 방법에 대해서 알아보겠습니다. 아래는 main 브랜치에 push 했을 때 자동으로 실행되는 블로그 배포 YAML 파일입니다.</p>\n<deckgo-highlight-code language=\"yml\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">name: Deploy Gatsby Blog with GitHub Actions\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  deploy:\n    runs-on: ubuntu-22.04\n    permissions:\n      contents: write\n    concurrency:\n      group: ${{ github.workflow }}-${{ github.ref }}\n    steps:\n      # 1. 현재의 commit HEAD 에 위치하게 합니다.\n      - name: Checkout\n        uses: actions/checkout@v3\n\n      # 2. Node.js 18버전을 사용합니다.\n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: &#39;18.x&#39;\n\n      # 3. production 환경에서 필요한 의존성만 설치합니다.\n      - name: Install Dependencies\n        run: yarn install --production\n\n      # 4. &#39;.cache&#39; 폴더를 캐싱합니다.\n      - name: Cache Gatsby &#39;.cache&#39;\n        uses: actions/cache@v3\n        id: gatsby-cache\n        with:\n          path: .cache\n          key: ${{ runner.OS }}-cache-gatsby\n          restore-keys: |\n            ${{ runner.OS }}-cache-gatsby\n\n      # 5. &#39;public&#39; 폴더를 캐싱합니다.\n      - name: Cache Gatsby &#39;public&#39;\n        uses: actions/cache@v3\n        id: gatsby-public\n        with:\n          path: public\n          key: ${{ runner.OS }}-public-gatsby\n          restore-keys: |\n            ${{ runner.OS }}-public-gatsby\n\n      # 6. 배포에 필요한 Build 파일을 생성합니다.\n      - name: Run Build\n        run: yarn build --prefix-paths\n        env:\n          NODE_ENV: production\n\n      # 7. 배포합니다.\n      - name: Deploy\n        uses: peaceiris/actions-gh-pages@v3\n        if: ${{ github.ref == &#39;refs/heads/main&#39; }}\n        with:\n          github_token: ${{ secrets.ACCESS_TOKEN }}\n          publish_branch: gh-pages\n          publish_dir: ./public</code>\n        </deckgo-highlight-code>\n<p>4번과 5번 단계에서 <code>.cache</code> 와 <code>public</code> 을 캐싱했습니다.</p>\n<h3>3. 배포 속도 개선으로 생산성 높이기</h3>\n<p>1편의 <a href=\"https://mnxmnz.github.io/frontend/caching-dependencies-to-speed-up-workflows\" target=\"_blank\" rel=\"nofollow\">Gatsby 블로그 배포 속도 개선으로 생산성 높이기</a> 의 의존성 캐싱과 2편의 빌드 결과물 캐싱 과정을 모두 실행하는 최종 <code>yml</code> 파일은 다음과 같습니다.</p>\n<deckgo-highlight-code language=\"yml\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">name: Deploy Gatsby Blog with GitHub Actions\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  deploy:\n    runs-on: ubuntu-22.04\n    permissions:\n      contents: write\n    concurrency:\n      group: ${{ github.workflow }}-${{ github.ref }}\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: &#39;18.x&#39;\n\n      # 의존성을 캐싱합니다.\n      - name: Cache Dependencies\n        id: yarn-cache\n        uses: actions/cache@v3\n        with:\n          # 캐시 대상을 정합니다.\n          path: node_modules\n          # 캐시 무효화는 yarn.lock 파일을 기준으로 합니다.\n          key: ${{ runner.OS }}-yarn-${{ hashFiles(&#39;**/yarn.lock&#39;) }}\n          restore-keys: |\n            ${{ runner.OS }}-yarn-\n\n      # yarn.lock 파일이 변경되지 않았다면 캐싱된 node_modules 를 사용합니다.\n      # 복구할 캐시가 없을 때만 의존성을 설치합니다.\n      - name: Install Dependencies\n        if: steps.yarn-cache.outputs.cache-hit != &#39;true&#39;\n        run: yarn install --production --pure-lockfile\n\n      - name: Cache Gatsby &#39;.cache&#39;\n        uses: actions/cache@v3\n        id: gatsby-cache\n        with:\n          path: .cache\n          key: ${{ runner.OS }}-cache-gatsby\n          restore-keys: |\n            ${{ runner.OS }}-cache-gatsby\n\n      - name: Cache Gatsby &#39;public&#39;\n        uses: actions/cache@v3\n        id: gatsby-public\n        with:\n          path: public\n          key: ${{ runner.OS }}-public-gatsby\n          restore-keys: |\n            ${{ runner.OS }}-public-gatsby\n\n      - name: Run Build\n        run: yarn build --prefix-paths\n        env:\n          NODE_ENV: production\n\n      - name: Deploy\n        uses: peaceiris/actions-gh-pages@v3\n        if: ${{ github.ref == &#39;refs/heads/main&#39; }}\n        with:\n          github_token: ${{ secrets.ACCESS_TOKEN }}\n          publish_branch: gh-pages\n          publish_dir: ./public</code>\n        </deckgo-highlight-code>\n<p>이러한 의존성 및 빌드 파일 캐싱으로 배포 속도를 개선해서 전체 배포 시간 6분 59초를 2분 27초로 단축할 수 있었습니다 🎉</p>\n<h2>마치며</h2>\n<ol>\n<li><code>gatsby build</code> 명령어로 사이트를 웹 브라우저에 전달할 수 있는 정적 파일로 컴파일합니다. 정적 파일은 브라우저에서 로딩되고 클라이언트 측에서는 리액트 애플리케이션으로 재구성됩니다.</li>\n<li>빌드 과정은 Node 객체 생성, 스키마 생성, 페이지 생성, GraphQL 쿼리 실행, 정적 파일 생성 단계를 거칩니다.</li>\n<li>Gatsby는 파일 시스템으로 변경을 감지하여 필요한 부분만 다시 빌드합니다. 중간 결과를 저장하는 역할을 하는 <code>.cache</code> 디렉터리를 활용하여 이전 작업 결과를 재사용합니다.</li>\n<li><code>package.json</code>, <code>gatsby-config.js</code>, <code>gatsby-node.js</code> 파일이 변경되거나 업데이트될 때 캐시를 갱신합니다.</li>\n</ol>\n<blockquote>\n<p>블로그 배포 속도 개선 관련 글은 1편과 2편으로 이루어져 있습니다.</p>\n</blockquote>\n<ul>\n<li><a href=\"https://mnxmnz.github.io/frontend/caching-dependencies-to-speed-up-workflows\" target=\"_blank\" rel=\"nofollow\">Gatsby 블로그 배포 속도 개선으로 생산성 높이기 (1)</a></li>\n<li><a href=\"https://mnxmnz.github.io/frontend/caching-build-outputs-to-speed-up-workflows\" target=\"_blank\" rel=\"nofollow\">Gatsby 블로그 배포 속도 개선으로 생산성 높이기 (2)</a></li>\n</ul>\n<hr>\n<p>참고 자료</p>\n<ul>\n<li><a href=\"https://www.gatsbyjs.com/docs/conceptual/overview-of-the-gatsby-build-process\" target=\"_blank\" rel=\"nofollow\">Overview of the Gatsby Build Process | Gatsby</a></li>\n<li><a href=\"https://www.gatsbyjs.com/docs/build-caching\" target=\"_blank\" rel=\"nofollow\">Build Caching | Gatsby</a></li>\n</ul>","timeToRead":5,"frontmatter":{"title":"Gatsby 블로그 배포 속도 개선으로 생산성 높이기 (2)","summary":"1편에서는 의존성 캐싱으로 배포 속도를 개선하고 이번에는 빌드 결과물 캐싱으로 개선했습니다. Gatsby의 빌드 과정과 캐싱 방법을 소개합니다.","date":"2022-12-04","category":"Deployment","thumbnail":{"publicURL":"/static/bc53abf718ed1fc13ea93903ba3ac9e1/thumbnail.jpeg"}}}}]}},"pageContext":{"slug":"/deployment/caching-build-outputs-to-speed-up-workflows/"}},"staticQueryHashes":["1663765485","2170400879","3026479947","4290078607"]}